1) Попробуйте самостоятельно перегрузить оператор сложения. Для его перегрузки используется метод __add__(). Он вызывается, когда объекты класса, имеющего данный метод, фигурируют в операции сложения, причем с левой стороны. Это значит, что в выражении a + b у объекта a должен быть метод __add__(). Объект b может быть чем угодно, но чаще всего он бывает объектом того же класса. Объект b будет автоматически передаваться в метод __add__() в качестве второго аргумента (первый – self).

Отметим, в Python также есть правосторонний метод перегрузки сложения - __radd__().

Согласно полиморфизму ООП, возвращать метод __add__() может что угодно. Может вообще ничего не возвращать, а молча вносить изменения в какие-то уже существующие объекты. Допустим, в вашей программе метод перегрузки сложения будет возвращать новый объект того же класса.

2) Разработать класс, который наследует функциональность стандартного типа str и содержит 2 новых метода:

метод is_repeatance (s), который принимает 1 аргумент s и возвращает True или False в зависимости от того, может ли текущая строка быть получена целым количеством повторов строки s. Вернуть False, если s не является строкой. Считать, что пустая строка не содержит повторов.
метод is_palindrom (), который возвращает True или False в зависимости от того, является ли строка палиндромом. Регистрами символов пренебрегать. Пустую строку считать палиндромом.

3) Доработать пример из лекции.
Условие: 
Пусть у нас будет класс "Цилиндр". При создании объектов от этого класса у них заводятся поля высота и диаметр, а также площадь поверхности. Вычисление площади можно поместить в отдельную статическую функцию. Она вроде и относится к цилиндрам, но с другой стороны само вычисление объекта не требует и может быть использовано где угодно.

from math import pi
 
class Cylinder:
    @staticmethod
    def make_area(d, h):
        circle = pi * d ** 2 / 4
        side = pi * d * h
        return round(circle*2 + side, 2)
 
    def __init__(self, di, hi):
        self.dia = diameter
        self.h = high
        self.area = self.make_area(di, hi)
 
 
a = Cylinder(1, 2)
print(a.area)
 
print(a.make_area(2, 2))

Приведенный пример плохой. Мы можем менять значения полей dia и h объекта за пределами класса простым присваиванием (например, a.dia = 10). При этом площадь никак не будет пересчитываться. Также мы можем назначить новое значение для площади, как простым присваиванием, так и вызовом функции make_area() с последующим присваиванием. Например, a.area = a.make_area(2, 3). При этом не меняются высота и диаметр.

Защитите код от возможных логических ошибок следующим образом:

Свойствам dia и h объекта по-прежнему можно выполнять присваивание за пределами класса. Однако при этом "за кулисами" происходит пересчет площади, т. е. изменение значения area.

Свойству area нельзя присваивать за пределами класса. Можно только получать его значение.

Подсказка: вспомните про метод __setattr__(), упомянутый в уроке про инкапсуляцию.